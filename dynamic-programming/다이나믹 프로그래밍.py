"""
Dynamic programming, 동적 계획법
메모리 공간을 약간 더 사용해 연산 속도를 비약적으로 증가시키는 방법

조건
1. 큰 문제를 작은 문제로 나눌 수 있다
2. 작은 문제에서 구한 정답은 그것을 포함하는 큰 문제에서도 동일하다. (부분 문제들의 중복)

종류
- 탑다운 Top-Down = 하향식
    큰 문제를 해결하기 위해 작은 문제를 호출하는 기법
    재귀 함수를 사용해 작성
    재귀 함수로 인한 오버헤드가 있다

- 보텀업 Bottom-Up = 상향식 ★
    작은 문제부터 차근차근 답을 도출하는 기법
    반복문을 사용해 작성
    일반적으로 탑다운 방식보다 성능이 좋다

- 메모이제이션 Memoization = 캐싱 Caching
    한번 구한 결과를 메모리 공간에 메모해두고 같은 식을 호출하면 메모한 결과를 그대로 가져오는 기법

- DP 테이블
    보텀업 방식에 사용되는 결과 저장용 리스트

an 을 계산할때 a0~an-1 이 아닌 일부만 사용될 경우에는
메모이제이션에 dict 자료형을 사용하는 것이 유리하다.

"""
# 예제 - 피보나치 수열
# 일반적인 재귀함수로 구현할 시 O(2^N) 의 시간 복잡도를 가진다.
# 이는 N 이 늘어날수록 연산 횟수가 기하급수적으로 늘어남을 의미한다. (30->10억회)
def late_pibo(x):
  if x == 1 or x == 2:
    return 1
  return late_pibo(x - 1) + late_pibo(x - 2)

# 탑다운 + 메모이제이션으로 구현한 피보나치 수열
# 시간 복잡도: O(N)
d = [0] * 100
def pibo(x):
  if x == 1 or x == 2:
    return 1
  # 이미 계산한 적 있는 문제라면 그대로 반환
  if d[x] != 0:
    return d[x]
  d[x] = pibo(x - 1) + pibo(x - 2)
  return d[x]

print(pibo(99))

# 보텀업 + DP 테이블로 구현한 피보나치 수열
# 시간 복잡도: O(N)
d = [0] * 100
d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
  d[i] = d[i - 1] + d[i - 2]

print(d[n])